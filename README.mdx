# ðŸš€ Jenkins RAG Application  
_Your complete end-to-end Retrieval-Augmented Generation system for Jenkins builds._

This project collects Jenkins build data, converts it into embeddings, stores it inside a FAISS vector database, and exposes a **Flask API** that answers questions using a **local LLM (Qwen 0.5B)**.

---

## ðŸ“‚ Project Structure

project/
â”‚â”€â”€ collector.py # Pulls Jenkins build info â†’ JSONL
â”‚â”€â”€ build_rag.py # Builds FAISS index + metadata
â”‚â”€â”€ query_rag.py # CLI testing for RAG answers
â”‚â”€â”€ app.py # Flask API (RAG backend)
â”‚â”€â”€ data/
â”‚ â””â”€â”€ jenkins_data.jsonl
â”‚â”€â”€ rag_store/
â”‚ â”œâ”€â”€ faiss.index
â”‚ â””â”€â”€ metadata.json
â”‚â”€â”€ README.mdx


---

Install Dependencies

Run:

```bash
pip install flask faiss-cpu sentence-transformers transformers requests

Step 1 â€” Run Jenkins Collector

This script connects to your Jenkins server, fetches build logs, and appends them into:

data/jenkins_data.jsonl

Run:

python collector.py

It will:

    Continuously check Jenkins every 10 seconds

    Detect new builds only

    Append clean text + raw JSON for each build

    You must have Jenkins running at the configured URL inside collector.py.

Step 2 â€” Build the FAISS Vector Store

python build_rag.py

This:

    Reads all JSON records

    Embeds them with all-MiniLM-L6-v2

    Creates faiss.index

    Saves metadata to rag_store/metadata.json

When complete:

RAG index built successfully!

Step 3 â€” Start the Flask API Server

python app.py

The API runs on:

http://localhost:5000